---
title: POI 解析 Excel 防范 Zip 炸弹
date: 2026-01-09
categories:
- 开发
tags:
- POI
- Excel
- Java
---

POI 解析 Excel 防范 Zip 炸弹

# POI 解析 Excel 防范 Zip 炸弹

最近公司的测试在组织安全测试时，构造了 Excel Zip 炸弹，导致我们的服务 OOM 挂掉，我们的服务实际上对 Zip 炸弹有统一的防护，读取 Excel 也是使用的流式读取，但为何 OOM 了呢？

## Excel 炸弹

Excel 文件实际上是一个 Zip 压缩包，里面有大量 xml 文件，因此存在两种比较显然的攻击方式：

1. **Zip 炸弹攻击**
2. XML 攻击

主要介绍一下第一种方式，第二种方式可以自行了解

## 构造 Excel Zip 炸弹

将 Excel 文件作为 Zip 文件解压，可以看到在 xl 目录下有一个 sharedStrings.xml 文件，里面存在这样的标签：

```Xml
<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="1" uniqueCount="1"><si><t>aaa</t></si></sst>
```

Excel 不会在每个单元格里重复存储相同的字符串，而是将所有唯一的字符串存放在这个 XML 中，单元格只引用其索引，所以这个标签里面的东西就是**单元格里的文本**

利用 Zip 对重复字符的高压缩比，可以向标签中写入大量文本，而压缩后的 Excel 文件本身却很小

实践一下：

1. 构造大量重复字符串到标签中

```Python
import zipfile

# 配置：10 个字符串，每个 100MB
count = 10
size_per_string = 100 * 1024 * 1024

if __name__ == '__main__':
    with zipfile.ZipFile("resources/normal.xlsx") as i, zipfile.ZipFile("resources/bomb.xlsx", "w", compression=zipfile.ZIP_DEFLATED) as z:
        [z.writestr(f, i.read(f)) for f in i.namelist() if f != "xl/sharedStrings.xml"]
        # 1. 构造多个 <si><t>...</t></si> 标签
        # 使用生成器表达式以节省 Python 运行时的内存
        strings_xml = "".join(f'<si><t>{"S" * size_per_string}</t></si>' for _ in range(count))
        sst_content = f'<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="{count}" uniqueCount="{count}">{strings_xml}</sst>'
        z.writestr("xl/sharedStrings.xml", sst_content)
```

在当前目录的 resources 下放置一个普通的 xlsx 文件：normal.xlsx，不填充任何信息，使用上面的 python 脚本（AI 生成）生成一个以该文件为模板的 Excel 炸弹，文件大小仅有不到 1 MB，但解压后却接近 1G ！

尝试使用 POI 流式读取该文件，看看会发生什么？

大部分代码由 AI 友情提供：

```Java
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.openxml4j.opc.OPCPackage;
import org.apache.poi.openxml4j.opc.PackageAccess;
import org.apache.poi.xssf.eventusermodel.ReadOnlySharedStringsTable;
import org.apache.poi.xssf.eventusermodel.XSSFReader;
import org.apache.poi.xssf.eventusermodel.XSSFSheetXMLHandler;
import org.apache.poi.xssf.model.StylesTable;
import org.apache.poi.xssf.usermodel.XSSFComment;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import java.io.InputStream;

@Slf4j
public class ExcelStreamingReader {

    public static void main(String[] args) throws Exception {
        ExcelStreamingReader reader = new ExcelStreamingReader();
        String bombPath = reader.getClass().getClassLoader().getResource("bomb.xlsx").toURI().getPath();
        reader.processExcel(bombPath);
    }

    public void processExcel(String filePath) throws Exception {
        // 1. 以只读模式打开包，不加载到内存
        try (OPCPackage pkg = OPCPackage.open(filePath, PackageAccess.READ)) {
            XSSFReader reader = new XSSFReader(pkg);

            // 2. 注意：这里使用了 ReadOnlySharedStringsTable
            // 它比常规的 SharedStringsTable 更省内存，但面对“炸弹”仍需小心
            ReadOnlySharedStringsTable sst = new ReadOnlySharedStringsTable(pkg);
            StylesTable styles = reader.getStylesTable();

            // 3. 获取所有 Sheet 的迭代器
            XSSFReader.SheetIterator iter = (XSSFReader.SheetIterator) reader.getSheetsData();
            while (iter.hasNext()) {
                try (InputStream sheetStream = iter.next()) {
                    processSheet(styles, sst, sheetStream);
                }
            }
        }
    }

    private void processSheet(StylesTable styles, ReadOnlySharedStringsTable sst, InputStream sheetStream) throws Exception {
        // 4. 设置 SAX 解析器
        XMLReader sheetParser = XMLReaderFactory.createXMLReader();

        // 5. 编写具体的行/列处理逻辑
        XSSFSheetXMLHandler.SheetContentsHandler handler = new XSSFSheetXMLHandler.SheetContentsHandler() {

            @Override
            public void startRow(int i) {

            }

            @Override
            public void endRow(int i) {

            }

            @Override
            public void cell(String s, String s1, XSSFComment xssfComment) {
                log.info(s);
            }
        };

        // 6. 结合 Styles 和 SharedStrings 进行解析
        sheetParser.setContentHandler(new XSSFSheetXMLHandler(styles, sst, handler, false));
        sheetParser.parse(new InputSource(sheetStream));
    }
}
```

默认执行会抛出以下异常：

```Java
// 截取的部分报错
You can adjust this limit via ZipSecureFile.setMinInflateRatio() if you need to work with files which exceed this limit.
Uncompressed size: 106532, Raw/compressed size: 512, ratio: 0.004806
Limits: MIN_INFLATE_RATIO: 0.010000, Entry: xl/sharedStrings.xml
 at org.apache.poi.openxml4j.util.ZipArchiveThresholdInputStream.checkThreshold(ZipArchiveThresholdInputStream.java:143)
 at org.apache.poi.openxml4j.util.ZipArchiveThresholdInputStream.read(ZipArchiveThresholdInputStream.java:82)
```

实际上，POI 会在解压 Excel 文件过程中同时校验文件的压缩比，如果压缩比默认的 0.01 还小的话就会抛出这样的异常，那么 POI 默认行为是否已经足够安全了呢，并不是，攻击者完全可以构造一个压缩比大于 0.01 的 Excel 文件，无非就是 Excel 文件大点而已

仔细观察报错信息，可以看到，我们可以通过设置 `ZipSecureFile.setMinInflateRatio()` 压缩比来控制压缩比，构造指定压缩比的 Excel 比较复杂，我们通过将最小压缩比调小的方式来看被这个 Zip 炸弹攻击的下场

在代码中添加一行：

```Java
ZipSecureFile.setMinInflateRatio(0.0001);
```

运行时限制 JVM 堆大小 `-Xmx512m` ，这个时候就会 OOM，转储堆内存分析后其实可以发现，大部分内存是被 `byte[]` 占用了，其实就是字符串

```Java
ERROR StatusLogger Log4j2 could not find a logging implementation. Please add log4j-core to the classpath. Using SimpleLogger to log to the console...
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
 at java.base/java.util.Arrays.copyOfRangeByte(Arrays.java:3863)
```

## 通过调整压缩比和限制文件大小来防御 Zip 炸弹

仔细观察报错信息，可以看到，我们可以通过设置 `ZipSecureFile.setMinInflateRatio()` 压缩比来控制压缩比，那么我们调整这个压缩比并且控制文件大小是否是可能可行的方案呢？

实际上，调整压缩比 + 检验 Excel 文件大小确实已经可以防护住 Zip 炸弹了，这也是我们公司目前使用的方案，在我们大多数服务和业务中运行得很好，不过要注意一个坑点，那就是**安全压缩比参数是一个 `static` 变量**，查看 `ZipSecureFile` 的代码就可以看到，所以需要注意需要**在项目启动时就配置好**，不要每次使用时进行设置，否则会出现并发问题

这套方案实际上还是存在一定问题，那就是当业务表格足够复杂时，业务表格本身的压缩比就极高，这时候就很难区分炸弹和实际业务表格的边界了，这就是我们目前遇到的问题，我们将安全压缩比设置得过于低了，没有防住测试构造的炸弹

## 限制 sharedStrings.xml 标签字符长度

其实，还可以通过限制 sharedStrings.xml 中标签字符串长度来防御

观察 `ReadOnlySharedStringsTable` 的实现，其中有 readFrom 方法来读取 sharedStrings.xml

```Java
public void readFrom(InputStream is) throws IOException, SAXException {
   PushbackInputStream pis = new PushbackInputStream(is, 1);
   int emptyTest = pis.read();
   if (emptyTest > -1) {
      pis.unread(emptyTest);
      InputSource sheetSource = new InputSource(pis);

      try {
            XMLReader sheetParser = XMLHelper.newXMLReader();
            sheetParser.setContentHandler(this);
            sheetParser.parse(sheetSource);
      } catch (ParserConfigurationException var6) {
            ParserConfigurationException e = var6;
            throw new SAXException("SAX parser appears to be broken - " + e.getMessage());
      }
   }

}
```

`sheetParser.setContentHandler(this)` 这行将 XML 解析的回调设置为自己，因为 `ReadOnlySharedStringsTable` 继承了 `org.xml.sax.helpers.DefaultHandler`，还重写了 `startElement`、`endElement`、`characters` 方法，这三个方法实际上看名字就能猜到作用分别是：

- 开始一个元素标签时的回调
- 结束一个元素标签时的回调
- 读取标签元素的回调（这里是流式读取，一次只读指定大小的块）

问题其实就出在 `characters` 方法上，他每次读取到标签内容后都累加到 `private StringBuilder characters` 中，所以我们可以继承一下重写这个类

```Java
import org.apache.poi.openxml4j.opc.OPCPackage;
import org.apache.poi.xssf.eventusermodel.ReadOnlySharedStringsTable;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

import java.io.IOException;

public class SafeReadOnlySharedStringsTable extends ReadOnlySharedStringsTable {
    private static final int MAX_ELEMENT_LEN = 100 * 10000;

    private int elementLen = 0;

    public SafeReadOnlySharedStringsTable(OPCPackage pkg) throws IOException, SAXException {
        super(pkg);
    }

    @Override
    public void startElement(String uri, String localName, String name, Attributes attributes) throws SAXException {
        super.startElement(uri, localName, name, attributes);
        elementLen = 0;
    }

    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        super.characters(ch, start, length);
        elementLen += length;
        if (elementLen > MAX_ELEMENT_LEN) {
            throw new SAXException("Too big elements in sharedStrings");
        }
    }
}
```

将解析 Excel 时使用的 `SharedStringsTable` 替换为这个实现就可以了

# 扩展

其实除了 sharedStrings.xml 外，样式文件 styles.xml 也可能受到构造大量标签的攻击，但其实我们业务上一般不需要 Excel 样式，我们只是读取数据，所以其实直接丢弃掉样式就好了

```Java
while (iter.hasNext()) {
      // 样式直接不要
      try (InputStream sheetStream = iter.next()) {
         processSheet(null, sst, sheetStream);
      }
}
```

还有一种不需要自己操心的方案就是直接使用 **EasyExcel**，它对 SharedStrings 和样式文件都有专门的解决方法，解析时不会导致 OOM